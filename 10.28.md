# 10.22-10.28 Learning Notes

# printf & scanf in c++
<https://stackoverflow.com/questions/4264127/correct-format-specifier-for-double-in-printf>
## printf("%f")==printf("%lf%")
Only use %f is OK
## scanf("%f")!=scanf("%lf")  
"%f" is the (or at least one) correct format for a double. There is no format for a float, because if you attempt to pass a float to printf, it'll be promoted to double before printf receives it. "%lf" is also acceptable under the current standard -- the l is specified as having no effect if followed by the f conversion specifier (among others).

Note that this is one place that printf format strings differ substantially from scanf (and fscanf, etc.) format strings. For output, you're passing a value, which will be promoted from float to double when passed as a variadic parameter. For input you're passing a pointer, which is not promoted, so you have to tell scanf whether you want to read a float or a double, so for scanf, %f means you want to read a float and %lf means you want to read a double (and, for what it's worth, for a long double, you use %Lf for either printf or scanf).

# Machine Learning
<https://gitbook.cn/gitchat/column/5d9efd3feb954a204f3ab13d>  
## PDF：probability density function 概率密度函数
在数学中，连续型随机变量的概率密度函数（在不至于混淆时可以简称为密度函数）是一个描述这个随机变量的输出值，在某个确定的取值点附近的可能性的函数。

## PMF: probability mass function概率质量函数
在概率论中，概率质量函数是离散随机变量在各特定取值上的概率。

## CDF :cumulative distribution function累积分布函数
是概率密度函数的积分，能完整描述一个实随机变量X的概率分布。
## Why use fig, ax = plt.subplots(3, 1)
<https://stackoverflow.com/questions/34162443/why-do-many-examples-use-fig-ax-plt-subplots-in-matplotlib-pyplot-python>  
plt.subplots() is a function that returns a tuple containing a figure and axes object(s). Thus when using fig, ax = plt.subplots() you unpack this tuple into the variables fig and ax. Having fig is useful if you want to change figure-level attributes or save the figure as an image file later (e.g. with fig.savefig('yourfilename.png')).
## Binominal Distribution
$$P(X=k)=C_n^kp^k(1-p)^{n-k}$$
Draw PMF Graph:
```python
from scipy.stats import binom
import matplotlib.pyplot as plt
import seaborn
seaborn.set()

fig, ax = plt.subplots(1, 1)
x = range(0, 11)

binom_rv = binom(n=10, p=0.25)
ax.plot(x, binom_rv.pmf(x), 'bo', ms=8)
ax.vlines(x, 0, binom_rv.pmf(x), colors='b', lw=3)
ax.set_xlim(0, 10)
ax.set_ylim(0, 0.35)
ax.set_xticks(x)
ax.set_yticks([0, 0.1, 0.2, 0.3])

plt.show()
```
Simulate:
```python
binom_rvs = binom_rv.rvs(size=100000)
E_sim = np.mean(binom_rvs)  # 期望
S_sim = np.std(binom_rvs)  # 标准差
V_sim = S_sim * S_sim  # 方差
```
## Geometric Distribution
$$P(X=k)=(1-p)^{k-1}p$$

# Nodejs+Express
## Static html
+ 设置首页  
+ 404页面  
+ 识别文件类型并正确显示
  
```js
./model/FromFileGetExtname.js
let fs = require('fs');
exports.getMime = function (fs, extname) {

    //异步程序
    // fs.readFile('./mime.json', (err, data) => {
    //     if (err) {
    //         console.log('not exist');
    //         return false;
    //     }
    //     let Mime = JSON.parse(data.toString());
    //     return Mime[extname];
    // })

    //改成同步读取
    let data = fs.readFileSync('./mime.json');
    let Mimes = JSON.parse(data.toString());//convert json into object
    return Mimes[extname];
}
```
```js
let http = require('http');
let fs = require('fs');
let path = require('path');
let url = require('url');
let extnameModel = require('./model/FromFileGetExtname.js');

http.createServer((req, res) => {
    let pathname = url.parse(req.url).pathname;//获取url请求
    if (pathname == '/') {
        pathname = '/index.html';//设置首页
    }
    let extname = path.extname(pathname);
    if (pathname != '/favicon.ico') {
        console.log(pathname);
        fs.readFile('static/' + pathname, (err, result) => {
            if (err) {
                console.error('404');

                fs.readFile('static/404.html', (err, errorData) => {//404 page
                    res.writeHead(404, { "Content-Type": "text/html;charset='utf-8'" });
                    res.write(errorData);
                    res.end();
                })
            }
            else {
                let name = extnameModel.getMime(fs,extname);//识别文件类型
                res.writeHead(200, { "Content-Type": "" + name + ";charset='utf-8'" });
                res.write(result);
                res.end();
            }
        })
    }
}).listen(3000);
```






